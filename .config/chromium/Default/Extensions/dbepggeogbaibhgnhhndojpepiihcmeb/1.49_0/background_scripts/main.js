// Generated by CoffeeScript 1.8.0
(function() {
  var BackgroundCommands, checkKeyQueue, completers, completionSources, copyToClipboard, currentVersion, fetchFileContents, filterCompleter, focusedFrame, frameIdsForTab, generateCompletionKeys, getActualKeyStrokeLength, getCompletionKeysRequest, getCurrentTabUrl, getCurrentTimeInSeconds, handleFrameFocused, handleKeyDown, handleSettings, handleUpdateScrollPosition, helpDialogHtmlForCommandGroup, isEnabledForUrl, keyQueue, moveTab, namedKeyRegex, openOptionsPageInNewTab, openUrlInCurrentTab, openUrlInIncognito, openUrlInNewTab, populateSingleKeyCommands, populateValidFirstKeys, portHandlers, refreshCompleter, registerFrame, removeTabsRelative, repeatFunction, root, saveHelpDialogSettings, selectSpecificTab, selectTab, selectionChangedHandlers, sendRequestHandlers, sendRequestToAllTabs, setBrowserActionIcon, shouldShowUpgradeMessage, singleKeyCommands, splitKeyIntoFirstAndSecond, splitKeyQueue, tabInfoMap, tabLoadedHandlers, tabQueue, unregisterFrame, updateActiveState, updateOpenTabs, updatePositionsAndWindowsForAllTabsInWindow, updateScrollPosition, upgradeNotificationClosed, validFirstKeys, whitespaceRegexp,
    __slice = [].slice;

  root = typeof exports !== "undefined" && exports !== null ? exports : window;

  currentVersion = Utils.getCurrentVersion();

  tabQueue = {};

  tabInfoMap = {};

  keyQueue = "";

  validFirstKeys = {};

  singleKeyCommands = [];

  focusedFrame = null;

  frameIdsForTab = {};

  namedKeyRegex = /^(<(?:[amc]-.|(?:[amc]-)?[a-z0-9]{2,5})>)(.*)$/;

  selectionChangedHandlers = [];

  tabLoadedHandlers = {};

  completionSources = {
    bookmarks: new BookmarkCompleter(),
    history: new HistoryCompleter(),
    domains: new DomainCompleter(),
    tabs: new TabCompleter(),
    seachEngines: new SearchEngineCompleter()
  };

  completers = {
    omni: new MultiCompleter([completionSources.seachEngines, completionSources.bookmarks, completionSources.history, completionSources.domains]),
    bookmarks: new MultiCompleter([completionSources.bookmarks]),
    tabs: new MultiCompleter([completionSources.tabs])
  };

  chrome.runtime.onConnect.addListener(function(port, name) {
    var senderTabId, toCall;
    senderTabId = port.sender.tab ? port.sender.tab.id : null;
    if (port.name === "domReady" && senderTabId !== null) {
      if (tabLoadedHandlers[senderTabId]) {
        toCall = tabLoadedHandlers[senderTabId];
        delete tabLoadedHandlers[senderTabId];
        toCall.call();
      }
      if (shouldShowUpgradeMessage()) {
        chrome.tabs.sendMessage(senderTabId, {
          name: "showUpgradeNotification",
          version: currentVersion
        });
      }
    }
    if (portHandlers[port.name]) {
      return port.onMessage.addListener(portHandlers[port.name]);
    }
  });

  chrome.runtime.onMessage.addListener(function(request, sender, sendResponse) {
    if (sendRequestHandlers[request.handler]) {
      sendResponse(sendRequestHandlers[request.handler](request, sender));
    }
    return false;
  });

  getCurrentTabUrl = function(request, sender) {
    return sender.tab.url;
  };

  root.isEnabledForUrl = isEnabledForUrl = function(request) {
    var rule;
    rule = Exclusions.getRule(request.url);
    return {
      rule: rule,
      isEnabledForUrl: !rule || rule.passKeys,
      passKeys: (rule != null ? rule.passKeys : void 0) || ""
    };
  };

  root.addExclusionRule = function(pattern, passKeys) {
    if (pattern = pattern.trim()) {
      Exclusions.updateOrAdd({
        pattern: pattern,
        passKeys: passKeys
      });
      return chrome.tabs.query({
        windowId: chrome.windows.WINDOW_ID_CURRENT,
        active: true
      }, function(tabs) {
        return updateActiveState(tabs[0].id);
      });
    }
  };

  root.removeExclusionRule = function(pattern) {
    if (pattern = pattern.trim()) {
      Exclusions.remove(pattern);
      return chrome.tabs.query({
        windowId: chrome.windows.WINDOW_ID_CURRENT,
        active: true
      }, function(tabs) {
        return updateActiveState(tabs[0].id);
      });
    }
  };

  saveHelpDialogSettings = function(request) {
    return Settings.set("helpDialog_showAdvancedCommands", request.showAdvancedCommands);
  };

  root.helpDialogHtml = function(showUnboundCommands, showCommandNames, customTitle) {
    var command, commandsToKey, dialogHtml, group, key;
    commandsToKey = {};
    for (key in Commands.keyToCommandRegistry) {
      command = Commands.keyToCommandRegistry[key].command;
      commandsToKey[command] = (commandsToKey[command] || []).concat(key);
    }
    dialogHtml = fetchFileContents("pages/help_dialog.html");
    for (group in Commands.commandGroups) {
      dialogHtml = dialogHtml.replace("{{" + group + "}}", helpDialogHtmlForCommandGroup(group, commandsToKey, Commands.availableCommands, showUnboundCommands, showCommandNames));
    }
    dialogHtml = dialogHtml.replace("{{version}}", currentVersion);
    dialogHtml = dialogHtml.replace("{{title}}", customTitle || "Help");
    return dialogHtml;
  };

  helpDialogHtmlForCommandGroup = function(group, commandsToKey, availableCommands, showUnboundCommands, showCommandNames) {
    var bindings, command, html, isAdvanced, _i, _len, _ref;
    html = [];
    _ref = Commands.commandGroups[group];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      command = _ref[_i];
      bindings = (commandsToKey[command] || [""]).join(", ");
      if (showUnboundCommands || commandsToKey[command]) {
        isAdvanced = Commands.advancedCommands.indexOf(command) >= 0;
        html.push("<tr class='vimiumReset " + (isAdvanced ? "advanced" : void 0) + "'>", "<td class='vimiumReset'>", Utils.escapeHtml(bindings), "</td>", "<td class='vimiumReset'>:</td><td class='vimiumReset'>", availableCommands[command].description);
        if (showCommandNames) {
          html.push("<span class='vimiumReset commandName'>(" + command + ")</span>");
        }
        html.push("</td></tr>");
      }
    }
    return html.join("\n");
  };

  fetchFileContents = function(extensionFileName) {
    var req;
    req = new XMLHttpRequest();
    req.open("GET", chrome.runtime.getURL(extensionFileName), false);
    req.send();
    return req.responseText;
  };

  getCompletionKeysRequest = function(request, keysToCheck) {
    if (keysToCheck == null) {
      keysToCheck = "";
    }
    return {
      name: "refreshCompletionKeys",
      completionKeys: generateCompletionKeys(keysToCheck),
      validFirstKeys: validFirstKeys
    };
  };

  openUrlInCurrentTab = function(request) {
    return chrome.tabs.getSelected(null, function(tab) {
      return chrome.tabs.update(tab.id, {
        url: Utils.convertToUrl(request.url)
      });
    });
  };

  openUrlInNewTab = function(request) {
    return chrome.tabs.getSelected(null, function(tab) {
      return chrome.tabs.create({
        url: Utils.convertToUrl(request.url),
        index: tab.index + 1,
        selected: true
      });
    });
  };

  openUrlInIncognito = function(request) {
    return chrome.windows.create({
      url: Utils.convertToUrl(request.url),
      incognito: true
    });
  };

  upgradeNotificationClosed = function(request) {
    Settings.set("previousVersion", currentVersion);
    return sendRequestToAllTabs({
      name: "hideUpgradeNotification"
    });
  };

  copyToClipboard = function(request) {
    return Clipboard.copy(request.data);
  };

  selectSpecificTab = function(request) {
    return chrome.tabs.get(request.id, function(tab) {
      chrome.windows.update(tab.windowId, {
        focused: true
      });
      return chrome.tabs.update(request.id, {
        selected: true
      });
    });
  };

  handleSettings = function(args, port) {
    var value;
    if (args.operation === "get") {
      value = Settings.get(args.key);
      return port.postMessage({
        key: args.key,
        value: value
      });
    } else {
      return Settings.set(args.key, args.value);
    }
  };

  refreshCompleter = function(request) {
    return completers[request.name].refresh();
  };

  whitespaceRegexp = /\s+/;

  filterCompleter = function(args, port) {
    var queryTerms;
    queryTerms = args.query === "" ? [] : args.query.split(whitespaceRegexp);
    return completers[args.name].filter(queryTerms, function(results) {
      return port.postMessage({
        id: args.id,
        results: results
      });
    });
  };

  getCurrentTimeInSeconds = function() {
    return Math.floor((new Date()).getTime() / 1000);
  };

  chrome.tabs.onSelectionChanged.addListener(function(tabId, selectionInfo) {
    if (selectionChangedHandlers.length > 0) {
      return selectionChangedHandlers.pop().call();
    }
  });

  repeatFunction = function(func, totalCount, currentCount, frameId) {
    if (currentCount < totalCount) {
      return func(function() {
        return repeatFunction(func, totalCount, currentCount + 1, frameId);
      }, frameId);
    }
  };

  moveTab = function(callback, direction) {
    return chrome.tabs.getSelected(null, function(tab) {
      return chrome.tabs.move(tab.id, {
        index: Math.max(0, tab.index + direction)
      }, callback);
    });
  };

  BackgroundCommands = {
    createTab: function(callback) {
      return chrome.tabs.create({
        url: Settings.get("newTabUrl")
      }, function(tab) {
        return callback();
      });
    },
    duplicateTab: function(callback) {
      return chrome.tabs.getSelected(null, function(tab) {
        chrome.tabs.duplicate(tab.id);
        return selectionChangedHandlers.push(callback);
      });
    },
    moveTabToNewWindow: function(callback) {
      return chrome.tabs.query({
        active: true,
        currentWindow: true
      }, function(tabs) {
        var tab;
        tab = tabs[0];
        return chrome.windows.create({
          tabId: tab.id,
          incognito: tab.incognito
        });
      });
    },
    nextTab: function(callback) {
      return selectTab(callback, "next");
    },
    previousTab: function(callback) {
      return selectTab(callback, "previous");
    },
    firstTab: function(callback) {
      return selectTab(callback, "first");
    },
    lastTab: function(callback) {
      return selectTab(callback, "last");
    },
    removeTab: function(callback) {
      return chrome.tabs.getSelected(null, function(tab) {
        chrome.tabs.remove(tab.id);
        return selectionChangedHandlers.push(callback);
      });
    },
    restoreTab: function(callback) {
      if (chrome.sessions) {
        return chrome.sessions.restore(null, function(restoredSession) {
          if (!chrome.runtime.lastError) {
            return callback();
          }
        });
      } else {
        return chrome.windows.getCurrent(function(window) {
          var tabQueueEntry;
          if (!(tabQueue[window.id] && tabQueue[window.id].length > 0)) {
            return;
          }
          tabQueueEntry = tabQueue[window.id].pop();
          if (tabQueue[window.id].length === 0) {
            delete tabQueue[window.id];
          }
          return chrome.tabs.create({
            url: tabQueueEntry.url,
            index: tabQueueEntry.positionIndex
          }, function(tab) {
            tabLoadedHandlers[tab.id] = function() {
              return chrome.tabs.sendRequest(tab.id, {
                name: "setScrollPosition",
                scrollX: tabQueueEntry.scrollX,
                scrollY: tabQueueEntry.scrollY
              });
            };
            return callback();
          });
        });
      }
    },
    openCopiedUrlInCurrentTab: function(request) {
      return openUrlInCurrentTab({
        url: Clipboard.paste()
      });
    },
    openCopiedUrlInNewTab: function(request) {
      return openUrlInNewTab({
        url: Clipboard.paste()
      });
    },
    togglePinTab: function(request) {
      return chrome.tabs.getSelected(null, function(tab) {
        return chrome.tabs.update(tab.id, {
          pinned: !tab.pinned
        });
      });
    },
    showHelp: function(callback, frameId) {
      return chrome.tabs.getSelected(null, function(tab) {
        return chrome.tabs.sendMessage(tab.id, {
          name: "toggleHelpDialog",
          dialogHtml: helpDialogHtml(),
          frameId: frameId
        });
      });
    },
    moveTabLeft: function(count) {
      return moveTab(null, -count);
    },
    moveTabRight: function(count) {
      return moveTab(null, count);
    },
    nextFrame: function(count, frameId) {
      return chrome.tabs.getSelected(null, function(tab) {
        var frames;
        frames = frameIdsForTab[tab.id];
        count = (count + Math.max(0, frameIdsForTab[tab.id].indexOf(frameId))) % frames.length;
        frames = frameIdsForTab[tab.id] = __slice.call(frames.slice(count)).concat(__slice.call(frames.slice(0, count)));
        return chrome.tabs.sendMessage(tab.id, {
          name: "focusFrame",
          frameId: frames[0],
          highlight: true
        });
      });
    },
    closeTabsOnLeft: function() {
      return removeTabsRelative("before");
    },
    closeTabsOnRight: function() {
      return removeTabsRelative("after");
    },
    closeOtherTabs: function() {
      return removeTabsRelative("both");
    }
  };

  removeTabsRelative = function(direction) {
    return chrome.tabs.query({
      currentWindow: true
    }, function(tabs) {
      return chrome.tabs.query({
        currentWindow: true,
        active: true
      }, function(activeTabs) {
        var activeTabIndex, shouldDelete, tab, toRemove, _i, _len;
        activeTabIndex = activeTabs[0].index;
        shouldDelete = (function() {
          switch (direction) {
            case "before":
              return function(index) {
                return index < activeTabIndex;
              };
            case "after":
              return function(index) {
                return index > activeTabIndex;
              };
            case "both":
              return function(index) {
                return index !== activeTabIndex;
              };
          }
        })();
        toRemove = [];
        for (_i = 0, _len = tabs.length; _i < _len; _i++) {
          tab = tabs[_i];
          if (!tab.pinned && shouldDelete(tab.index)) {
            toRemove.push(tab.id);
          }
        }
        return chrome.tabs.remove(toRemove);
      });
    });
  };

  selectTab = function(callback, direction) {
    return chrome.tabs.getAllInWindow(null, function(tabs) {
      if (!(tabs.length > 1)) {
        return;
      }
      return chrome.tabs.getSelected(null, function(currentTab) {
        var toSelect;
        switch (direction) {
          case "next":
            toSelect = tabs[(currentTab.index + 1 + tabs.length) % tabs.length];
            break;
          case "previous":
            toSelect = tabs[(currentTab.index - 1 + tabs.length) % tabs.length];
            break;
          case "first":
            toSelect = tabs[0];
            break;
          case "last":
            toSelect = tabs[tabs.length - 1];
        }
        selectionChangedHandlers.push(callback);
        return chrome.tabs.update(toSelect.id, {
          selected: true
        });
      });
    });
  };

  updateOpenTabs = function(tab) {
    var _ref;
    if ((_ref = tabInfoMap[tab.id]) != null ? _ref.deletor : void 0) {
      clearTimeout(tabInfoMap[tab.id].deletor);
    }
    tabInfoMap[tab.id] = {
      url: tab.url,
      positionIndex: tab.index,
      windowId: tab.windowId,
      scrollX: null,
      scrollY: null,
      deletor: null
    };
    return delete frameIdsForTab[tab.id];
  };

  setBrowserActionIcon = function(tabId, path) {
    return chrome.browserAction.setIcon({
      tabId: tabId,
      path: path
    });
  };

  updateActiveState = function(tabId) {
    var disabledIcon, enabledIcon, partialIcon;
    enabledIcon = "icons/browser_action_enabled.png";
    disabledIcon = "icons/browser_action_disabled.png";
    partialIcon = "icons/browser_action_partial.png";
    return chrome.tabs.get(tabId, function(tab) {
      return chrome.tabs.sendMessage(tabId, {
        name: "getActiveState"
      }, function(response) {
        var config, currentPasskeys, enabled, isCurrentlyEnabled, passKeys;
        if (response) {
          isCurrentlyEnabled = response.enabled;
          currentPasskeys = response.passKeys;
          config = isEnabledForUrl({
            url: tab.url
          });
          enabled = config.isEnabledForUrl;
          passKeys = config.passKeys;
          if (enabled && passKeys) {
            setBrowserActionIcon(tabId, partialIcon);
          } else if (enabled) {
            setBrowserActionIcon(tabId, enabledIcon);
          } else {
            setBrowserActionIcon(tabId, disabledIcon);
          }
          if (isCurrentlyEnabled !== enabled || currentPasskeys !== passKeys) {
            return chrome.tabs.sendMessage(tabId, {
              name: "setState",
              enabled: enabled,
              passKeys: passKeys
            });
          }
        } else {
          return setBrowserActionIcon(tabId, disabledIcon);
        }
      });
    });
  };

  handleUpdateScrollPosition = function(request, sender) {
    return updateScrollPosition(sender.tab, request.scrollX, request.scrollY);
  };

  updateScrollPosition = function(tab, scrollX, scrollY) {
    tabInfoMap[tab.id].scrollX = scrollX;
    return tabInfoMap[tab.id].scrollY = scrollY;
  };

  chrome.tabs.onUpdated.addListener(function(tabId, changeInfo, tab) {
    var cssConf;
    if (changeInfo.status !== "loading") {
      return;
    }
    cssConf = {
      allFrames: true,
      code: Settings.get("userDefinedLinkHintCss"),
      runAt: "document_start"
    };
    chrome.tabs.insertCSS(tabId, cssConf, function() {
      return chrome.runtime.lastError;
    });
    if (changeInfo.url != null) {
      updateOpenTabs(tab);
    }
    return updateActiveState(tabId);
  });

  chrome.tabs.onAttached.addListener(function(tabId, attachedInfo) {
    if (tabInfoMap[tabId]) {
      updatePositionsAndWindowsForAllTabsInWindow(tabInfoMap[tabId].windowId);
    }
    return updatePositionsAndWindowsForAllTabsInWindow(attachedInfo.newWindowId);
  });

  chrome.tabs.onMoved.addListener(function(tabId, moveInfo) {
    return updatePositionsAndWindowsForAllTabsInWindow(moveInfo.windowId);
  });

  chrome.tabs.onRemoved.addListener(function(tabId) {
    var i, openTabInfo;
    openTabInfo = tabInfoMap[tabId];
    updatePositionsAndWindowsForAllTabsInWindow(openTabInfo.windowId);
    if (!chrome.sessions) {
      if (/^(chrome|view-source:)[^:]*:\/\/.*/.test(openTabInfo.url)) {
        for (i in tabQueue[openTabInfo.windowId]) {
          if (tabQueue[openTabInfo.windowId][i].positionIndex > openTabInfo.positionIndex) {
            tabQueue[openTabInfo.windowId][i].positionIndex--;
          }
        }
        return;
      }
      if (tabQueue[openTabInfo.windowId]) {
        tabQueue[openTabInfo.windowId].push(openTabInfo);
      } else {
        tabQueue[openTabInfo.windowId] = [openTabInfo];
      }
    }
    tabInfoMap.deletor = function() {
      return delete tabInfoMap[tabId];
    };
    setTimeout(tabInfoMap.deletor, 1000);
    return delete frameIdsForTab[tabId];
  });

  chrome.tabs.onActiveChanged.addListener(function(tabId, selectInfo) {
    return updateActiveState(tabId);
  });

  if (!chrome.sessions) {
    chrome.windows.onRemoved.addListener(function(windowId) {
      return delete tabQueue[windowId];
    });
  }

  updatePositionsAndWindowsForAllTabsInWindow = function(windowId) {
    return chrome.tabs.getAllInWindow(windowId, function(tabs) {
      var openTabInfo, tab, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = tabs.length; _i < _len; _i++) {
        tab = tabs[_i];
        openTabInfo = tabInfoMap[tab.id];
        if (openTabInfo) {
          openTabInfo.positionIndex = tab.index;
          _results.push(openTabInfo.windowId = tab.windowId);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    });
  };

  splitKeyIntoFirstAndSecond = function(key) {
    if (key.search(namedKeyRegex) === 0) {
      return {
        first: RegExp.$1,
        second: RegExp.$2
      };
    } else {
      return {
        first: key[0],
        second: key.slice(1)
      };
    }
  };

  getActualKeyStrokeLength = function(key) {
    if (key.search(namedKeyRegex) === 0) {
      return 1 + getActualKeyStrokeLength(RegExp.$2);
    } else {
      return key.length;
    }
  };

  populateValidFirstKeys = function() {
    var key, _results;
    _results = [];
    for (key in Commands.keyToCommandRegistry) {
      if (getActualKeyStrokeLength(key) === 2) {
        _results.push(validFirstKeys[splitKeyIntoFirstAndSecond(key).first] = true);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  populateSingleKeyCommands = function() {
    var key, _results;
    _results = [];
    for (key in Commands.keyToCommandRegistry) {
      if (getActualKeyStrokeLength(key) === 1) {
        _results.push(singleKeyCommands.push(key));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  root.refreshCompletionKeysAfterMappingSave = function() {
    validFirstKeys = {};
    singleKeyCommands = [];
    populateValidFirstKeys();
    populateSingleKeyCommands();
    return sendRequestToAllTabs(getCompletionKeysRequest());
  };

  generateCompletionKeys = function(keysToCheck) {
    var command, completionKeys, count, key, splitHash, splitKey;
    splitHash = splitKeyQueue(keysToCheck || keyQueue);
    command = splitHash.command;
    count = splitHash.count;
    completionKeys = singleKeyCommands.slice(0);
    if (getActualKeyStrokeLength(command) === 1) {
      for (key in Commands.keyToCommandRegistry) {
        splitKey = splitKeyIntoFirstAndSecond(key);
        if (splitKey.first === command) {
          completionKeys.push(splitKey.second);
        }
      }
    }
    return completionKeys;
  };

  splitKeyQueue = function(queue) {
    var command, count, match;
    match = /([1-9][0-9]*)?(.*)/.exec(queue);
    count = parseInt(match[1], 10);
    command = match[2];
    return {
      count: count,
      command: command
    };
  };

  handleKeyDown = function(request, port) {
    var key;
    key = request.keyChar;
    if (key === "<ESC>") {
      console.log("clearing keyQueue");
      keyQueue = "";
    } else {
      console.log("checking keyQueue: [", keyQueue + key, "]");
      keyQueue = checkKeyQueue(keyQueue + key, port.sender.tab.id, request.frameId);
      console.log("new KeyQueue: " + keyQueue);
    }
    return chrome.tabs.sendMessage(port.sender.tab.id, {
      name: "currentKeyQueue",
      keyQueue: keyQueue
    });
  };

  checkKeyQueue = function(keysToCheck, tabId, frameId) {
    var command, count, newKeyQueue, refreshedCompletionKeys, registryEntry, runCommand, splitHash, splitKey;
    refreshedCompletionKeys = false;
    splitHash = splitKeyQueue(keysToCheck);
    command = splitHash.command;
    count = splitHash.count;
    if (command.length === 0) {
      return keysToCheck;
    }
    if (isNaN(count)) {
      count = 1;
    }
    if (Commands.keyToCommandRegistry[command]) {
      registryEntry = Commands.keyToCommandRegistry[command];
      runCommand = true;
      if (registryEntry.noRepeat) {
        count = 1;
      } else if (registryEntry.repeatLimit && count > registryEntry.repeatLimit) {
        runCommand = confirm("You have asked Vimium to perform " + count + " repeats of the command:\n" + Commands.availableCommands[registryEntry.command].description + "\n\nAre you sure you want to continue?");
      }
      if (runCommand) {
        if (!registryEntry.isBackgroundCommand) {
          chrome.tabs.sendMessage(tabId, {
            name: "executePageCommand",
            command: registryEntry.command,
            frameId: frameId,
            count: count,
            passCountToFunction: registryEntry.passCountToFunction,
            completionKeys: generateCompletionKeys("")
          });
          refreshedCompletionKeys = true;
        } else {
          if (registryEntry.passCountToFunction) {
            BackgroundCommands[registryEntry.command](count, frameId);
          } else if (registryEntry.noRepeat) {
            BackgroundCommands[registryEntry.command](frameId);
          } else {
            repeatFunction(BackgroundCommands[registryEntry.command], count, 0, frameId);
          }
        }
      }
      newKeyQueue = "";
    } else if (getActualKeyStrokeLength(command) > 1) {
      splitKey = splitKeyIntoFirstAndSecond(command);
      if (Commands.keyToCommandRegistry[splitKey.second]) {
        newKeyQueue = checkKeyQueue(splitKey.second, tabId, frameId);
      } else {
        newKeyQueue = (validFirstKeys[splitKey.second] ? splitKey.second : "");
      }
    } else {
      newKeyQueue = (validFirstKeys[command] ? count.toString() + command : "");
    }
    if (!refreshedCompletionKeys) {
      chrome.tabs.sendMessage(tabId, getCompletionKeysRequest(null, newKeyQueue), null);
    }
    return newKeyQueue;
  };

  sendRequestToAllTabs = function(args) {
    return chrome.windows.getAll({
      populate: true
    }, function(windows) {
      var tab, window, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = windows.length; _i < _len; _i++) {
        window = windows[_i];
        _results.push((function() {
          var _j, _len1, _ref, _results1;
          _ref = window.tabs;
          _results1 = [];
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            tab = _ref[_j];
            _results1.push(chrome.tabs.sendMessage(tab.id, args, null));
          }
          return _results1;
        })());
      }
      return _results;
    });
  };

  shouldShowUpgradeMessage = function() {
    if (!Settings.get("previousVersion")) {
      Settings.set("previousVersion", currentVersion);
    }
    return Utils.compareVersions(currentVersion, Settings.get("previousVersion")) === 1;
  };

  openOptionsPageInNewTab = function() {
    return chrome.tabs.getSelected(null, function(tab) {
      return chrome.tabs.create({
        url: chrome.runtime.getURL("pages/options.html"),
        index: tab.index + 1
      });
    });
  };

  registerFrame = function(request, sender) {
    var _name;
    return (frameIdsForTab[_name = sender.tab.id] != null ? frameIdsForTab[_name] : frameIdsForTab[_name] = []).push(request.frameId);
  };

  unregisterFrame = function(request, sender) {
    var tabId;
    tabId = sender.tab.id;
    if (frameIdsForTab[tabId] != null) {
      if (request.tab_is_closing) {
        return updateOpenTabs(sender.tab);
      } else {
        return frameIdsForTab[tabId] = frameIdsForTab[tabId].filter(function(id) {
          return id !== request.frameId;
        });
      }
    }
  };

  handleFrameFocused = function(request, sender) {
    var tabId;
    tabId = sender.tab.id;
    if (frameIdsForTab[tabId] != null) {
      return frameIdsForTab[tabId] = [request.frameId].concat(__slice.call(frameIdsForTab[tabId].filter(function(id) {
          return id !== request.frameId;
        })));
    }
  };

  portHandlers = {
    keyDown: handleKeyDown,
    settings: handleSettings,
    filterCompleter: filterCompleter
  };

  sendRequestHandlers = {
    getCompletionKeys: getCompletionKeysRequest,
    getCurrentTabUrl: getCurrentTabUrl,
    openUrlInNewTab: openUrlInNewTab,
    openUrlInIncognito: openUrlInIncognito,
    openUrlInCurrentTab: openUrlInCurrentTab,
    openOptionsPageInNewTab: openOptionsPageInNewTab,
    registerFrame: registerFrame,
    unregisterFrame: unregisterFrame,
    frameFocused: handleFrameFocused,
    nextFrame: function(request) {
      return BackgroundCommands.nextFrame(1, request.frameId);
    },
    upgradeNotificationClosed: upgradeNotificationClosed,
    updateScrollPosition: handleUpdateScrollPosition,
    copyToClipboard: copyToClipboard,
    isEnabledForUrl: isEnabledForUrl,
    saveHelpDialogSettings: saveHelpDialogSettings,
    selectSpecificTab: selectSpecificTab,
    refreshCompleter: refreshCompleter,
    createMark: Marks.create.bind(Marks),
    gotoMark: Marks.goto.bind(Marks)
  };

  window.runTests = function() {
    return open(chrome.runtime.getURL('tests/dom_tests/dom_tests.html'));
  };

  Commands.clearKeyMappingsAndSetDefaults();

  if (Settings.has("keyMappings")) {
    Commands.parseCustomKeyMappings(Settings.get("keyMappings"));
  }

  populateValidFirstKeys();

  populateSingleKeyCommands();

  if (shouldShowUpgradeMessage()) {
    sendRequestToAllTabs({
      name: "showUpgradeNotification",
      version: currentVersion
    });
  }

  chrome.windows.getAll({
    populate: true
  }, function(windows) {
    var createScrollPositionHandler, tab, window, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = windows.length; _i < _len; _i++) {
      window = windows[_i];
      _results.push((function() {
        var _j, _len1, _ref, _results1;
        _ref = window.tabs;
        _results1 = [];
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          tab = _ref[_j];
          updateOpenTabs(tab);
          createScrollPositionHandler = function() {
            return function(response) {
              if (response != null) {
                return updateScrollPosition(tab, response.scrollX, response.scrollY);
              }
            };
          };
          _results1.push(chrome.tabs.sendMessage(tab.id, {
            name: "getScrollPosition"
          }, createScrollPositionHandler()));
        }
        return _results1;
      })());
    }
    return _results;
  });

  Sync.init();

}).call(this);
